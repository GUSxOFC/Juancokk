Telegram Bot Runner — Complete Package

Di dokumen ini ada tiga file yang siap kamu salin/download:

1. index.html — Frontend untuk upload ZIP, kontrol start/stop, dan melihat status (uptime, memory, ping).


2. server.js — Backend Node.js minimal yang menerima ZIP, mengekstrak, menginstall dependensi, menjalankan bot di child process, dan menyediakan API status + stop.


3. README.md — Instruksi singkat untuk menjalankan di lokal atau di panel seperti Pterodactyl.



> Catatan penting: kode ini menjalankan skrip pihak ketiga. Untuk produksi, jalankan di lingkungan terisolasi (Docker/Pterodactyl) dan tambahkan autentikasi. Jangan menjalankan skrip dari sumber yang tidak dipercaya.




---

index.html

<!-- index.html -->
<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Telegram Bot Runner</title>
  <style>/* minimal styling omitted for brevity */</style>
</head>
<body>
  <h2>Upload ZIP Bot Telegram</h2>
  <input id="zipInput" type="file" accept=".zip" />
  <button id="uploadBtn">Upload & Start</button>
  <button id="stopBtn" disabled>Stop Bot</button>

  <div id="info">
    <p id="status">Status: idle</p>
    <p id="uptime">Uptime: -</p>
    <p id="mem">Memory: -</p>
    <p id="ping">Ping: -</p>
    <pre id="logs" style="height:200px;overflow:auto;background:#111;color:#0f0;padding:8px"></pre>
  </div>

  <script>
    // Frontend logic: upload ZIP to /api/run-bot, poll /api/status, stop via /api/stop-bot
    const zipInput = document.getElementById('zipInput')
    const uploadBtn = document.getElementById('uploadBtn')
    const stopBtn = document.getElementById('stopBtn')
    const statusEl = document.getElementById('status')
    const uptimeEl = document.getElementById('uptime')
    const memEl = document.getElementById('mem')
    const pingEl = document.getElementById('ping')
    const logsEl = document.getElementById('logs')

    let pollInterval = null

    uploadBtn.addEventListener('click', async ()=>{
      const f = zipInput.files[0]
      if(!f){ alert('Pilih file ZIP dulu'); return }
      uploadBtn.disabled = true
      statusEl.textContent = 'Mengunggah...'
      const fd = new FormData()
      fd.append('zip', f, f.name)
      try{
        const res = await fetch('/api/run-bot', { method:'POST', body: fd })
        const j = await res.json()
        if(res.ok){
          statusEl.textContent = 'Bot started (id: ' + j.jobId + ')'
          stopBtn.disabled = false
          startPolling()
        } else {
          statusEl.textContent = 'Error: ' + (j.message||res.status)
          uploadBtn.disabled = false
        }
      }catch(e){ statusEl.textContent = 'Upload failed: '+e.message; uploadBtn.disabled = false }
    })

    stopBtn.addEventListener('click', async ()=>{
      stopBtn.disabled = true
      try{
        await fetch('/api/stop-bot', { method:'POST' })
        statusEl.textContent = 'Stopping...'
      }catch(e){ statusEl.textContent = 'Stop failed: '+e.message }
    })

    function startPolling(){
      if(pollInterval) clearInterval(pollInterval)
      pollInterval = setInterval(async ()=>{
        try{
          const t0 = performance.now()
          const res = await fetch('/api/status')
          const t1 = performance.now()
          const data = await res.json()
          pingEl.textContent = (t1-t0).toFixed(0) + ' ms'
          statusEl.textContent = data.running ? 'Running' : 'Stopped'
          uptimeEl.textContent = data.uptime_str || '-'
          memEl.textContent = data.memory || '-'
          logsEl.textContent = (data.recent_logs||[]).join('
') + '
' + logsEl.textContent
          if(!data.running){ clearInterval(pollInterval); pollInterval = null; uploadBtn.disabled = false; stopBtn.disabled = true }
        }catch(e){ console.error(e); }
      }, 2000)
    }
  </script>
</body>
</html>


---

server.js

// server.js — Node.js backend (Express)
// Cara kerja singkat:
// - POST /api/run-bot : terima ZIP, simpan, ekstrak ke folder job, jalankan `npm install` lalu `node` child process ke file utama
// - POST /api/stop-bot: hentikan proses jika ada
// - GET /api/status: kembalikan { running, uptime, memory, recent_logs }

const express = require('express')
const multer = require('multer')
const fs = require('fs')
const path = require('path')
const { exec, spawn } = require('child_process')
const JSZip = require('jszip')

const app = express()
const upload = multer({ dest: 'uploads/' })

let job = { running:false, pid:null, startTime:null, cwd:null, logs:[] }

function log(msg){ const t = new Date().toISOString(); job.logs.unshift(`[${t}] ${msg}`); if(job.logs.length>200) job.logs.pop(); console.log(msg) }

app.post('/api/run-bot', upload.single('zip'), async (req, res) => {
  if(job.running) return res.status(400).json({ message: 'Already running' })
  const file = req.file
  if(!file) return res.status(400).json({ message: 'No zip uploaded' })

  try{
    const data = fs.readFileSync(file.path)
    const jszip = new JSZip()
    const zip = await jszip.loadAsync(data)
    const jobId = Date.now().toString()
    const jobDir = path.join(__dirname, 'jobs', jobId)
    fs.mkdirSync(jobDir, { recursive:true })

    // extract files
    const entries = Object.keys(zip.files)
    for(const name of entries){
      const entry = zip.files[name]
      const outPath = path.join(jobDir, name)
      if(entry.dir){ fs.mkdirSync(outPath, { recursive:true }); continue }
      const content = await entry.async('nodebuffer')
      fs.mkdirSync(path.dirname(outPath), { recursive:true })
      fs.writeFileSync(outPath, content)
    }

    // determine start script from package.json or first .js
    let startFile = null
    const pkgPath = path.join(jobDir, 'package.json')
    if(fs.existsSync(pkgPath)){
      const pkg = JSON.parse(fs.readFileSync(pkgPath,'utf8'))
      if(pkg.main) startFile = pkg.main
      else if(pkg.scripts && pkg.scripts.start){ startFile = null /* we'll run npm start */ }
    }
    if(!startFile){
      // find first .js in root
      const files = fs.readdirSync(jobDir)
      const js = files.find(f => f.endsWith('.js'))
      if(js) startFile = js
    }

    job.cwd = jobDir
    job.startTime = null

    // run npm install if package.json exists
    if(fs.existsSync(pkgPath)){
      log('Running npm install...')
      await new Promise((resolve, reject)=>{
        const p = spawn('npm', ['install','--production'], { cwd: jobDir, stdio: 'inherit' })
        p.on('close', code => code===0 ? resolve() : resolve())
      })
    }

    // start process
    if(fs.existsSync(pkgPath)){
      // use npm start if scripts.start exists
      const pkg = JSON.parse(fs.readFileSync(pkgPath,'utf8'))
      if(pkg.scripts && pkg.scripts.start){
        log('Starting via npm start')
        const p = spawn('npm', ['start'], { cwd: jobDir })
        job.pid = p.pid
        job.running = true
        job.startTime = Date.now()
        job.proc = p
        p.stdout.on('data', d=> log(d.toString()))
        p.stderr.on('data', d=> log(d.toString()))
        p.on('exit', ()=>{ job.running=false; job.pid=null; log('Process exited') })
      } else if(startFile){
        log('Starting node ' + startFile)
        const p = spawn('node', [startFile], { cwd: jobDir })
        job.pid = p.pid
        job.running = true
        job.startTime = Date.now()
        job.proc = p
        p.stdout.on('data', d=> log(d.toString()))
        p.stderr.on('data', d=> log(d.toString()))
        p.on('exit', ()=>{ job.running=false; job.pid=null; log('Process exited') })
      } else {
        return res.status(400).json({ message: 'No start file found' })
      }
    } else if(startFile){
      log('Starting node ' + startFile)
      const p = spawn('node', [startFile], { cwd: jobDir })
      job.pid = p.pid
      job.running = true
      job.startTime = Date.now()
      job.proc = p
      p.stdout.on('data', d=> log(d.toString()))
      p.stderr.on('data', d=> log(d.toString()))
      p.on('exit', ()=>{ job.running=false; job.pid=null; log('Process exited') })
    } else {
      return res.status(400).json({ message: 'No runnable JS found' })
    }

    // cleanup uploaded temp
    fs.unlinkSync(file.path)

    res.json({ jobId })
  }catch(e){ console.error(e); res.status(500).json({ message: e.message }) }
})

app.post('/api/stop-bot', (req, res)=>{
  if(!job.running || !job.proc) return res.json({ message: 'No running job' })
  try{
    job.proc.kill('SIGTERM')
    job.running = false
    res.json({ message: 'Stopping' })
  }catch(e){ res.status(500).json({ message: e.message }) }
})

app.get('/api/status', (req, res)=>{
  const running = !!job.running
  const uptime = running && job.startTime ? Date.now() - job.startTime : 0
  const uptimeStr = running ? msToString(uptime) : null
  const mem = process.memoryUsage()
  const memMb = Math.round(mem.rss/1024/1024) + ' MB'
  res.json({ running, uptime, uptime_str: uptimeStr, memory: memMb, recent_logs: job.logs.slice(0,30) })
})

function msToString(ms){
  const s = Math.floor(ms/1000)
  const h = Math.floor(s/3600); const m = Math.floor((s%3600)/60); const sec = s%60
  return `${h}h ${m}m ${sec}s`
}

app.use(express.static(path.join(__dirname, 'public')))

app.listen(3000, ()=> console.log('Server listening on :3000'))


---

README.md (ringkas)

# Telegram Bot Runner

1. Pasang Node.js (v16+)
2. Letakkan `server.js` di folder projek
3. Buat folder `public/` dan masukkan `index.html` ke dalamnya
4. `npm init -y && npm i express multer jszip`
5. Jalankan: `node server.js`
6. Buka http://localhost:3000 dan upload ZIP

**Keamanan**: jalankan di Docker/Pterodactyl, gunakan token/auth, batasi resource.


---

Jika kamu mau, saya bisa:

Mengemas ketiga file tersebut ke satu ZIP siap download, atau

Meng-generate Dockerfile + contoh docker-compose.yml untuk deploy di Pterodactyl.


Pilih tindakan: (A) Buat ZIP download sekarang, (B) Tambah Dockerfile, (C) Langsung deploy script untuk Pterodactyl.

  
